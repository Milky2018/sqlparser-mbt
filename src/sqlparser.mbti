package "Milky2018/sqlparser"

// Values
fn parse_sql(String) -> Statement raise SqlParserError

// Types and methods
pub(all) enum BinaryOperator {
  Eq
  Neq
  Lt
  Gt
  LtEq
  GtEq
  Spaceship
  Plus
  Minus
  Mul
  Div
  Mod
  And
  Or
}
fn BinaryOperator::get_precedence(Self) -> Precedence
impl Eq for BinaryOperator
impl Show for BinaryOperator

pub struct CaseExpr {
  operand : Expr?
  when_then_clauses : Array[(Expr, Expr)]
  else_expr : Expr?
}
impl Eq for CaseExpr
impl Show for CaseExpr

pub(all) enum DatetimeUnit {
  Year
  Month
  Day
  Hour
  Minute
  Second
}
impl Eq for DatetimeUnit
impl Show for DatetimeUnit

pub(all) enum Expr {
  Identifier(String)
  CompoundIdentifier(Array[String])
  Literal(Literal)
  BinaryOperation(Expr, BinaryOperator, Expr)
  UnaryOperation(UnaryOperator, Expr)
  FunctionCall(String, Array[Expr])
  Wildcard
  Datetime(String)
  Interval(String, IntervalQualifier)
  Like(positive~ : Bool, Expr, Expr)
  ILike(positive~ : Bool, Expr, Expr)
  SubQuery(SelectStmt)
  Exists(positive~ : Bool, SelectStmt)
  Between(positive~ : Bool, Expr, Expr, Expr)
  Extract(PrimaryDatetimeField, Expr)
  Case(CaseExpr)
}
impl Eq for Expr
impl Show for Expr

pub(all) enum IntervalQualifier {
  Single(PrimaryDatetimeField)
  Range(PrimaryDatetimeField, PrimaryDatetimeField)
}
impl Eq for IntervalQualifier
impl Show for IntervalQualifier

pub(all) enum Keyword {
  Select
  From
  Where
  As
  Group
  Order
  By
  Asc
  Desc
  Nulls
  First
  Last
  Year
  Month
  Day
  Hour
  Minute
  Second
  Date
  Interval
  To
  Like
  Not
  ILike
  Exists
  Between
  And
  Or
  Extract
  Case
  When
  Then
  Else
  Having
  End
}
impl Eq for Keyword
impl Show for Keyword

type Lexer
fn Lexer::lex(Self) -> Array[Token] raise LexerError
fn Lexer::new(String) -> Self

type LexerError
impl Show for LexerError

pub(all) enum Literal {
  Integer(Int)
  Double(Double)
  String(String)
  Boolean(Bool)
  Null
}
impl Eq for Literal
impl Show for Literal

pub struct OrderByExpr {
  expr : Expr
  asc : Bool?
  nulls_first : Bool?
}
impl Eq for OrderByExpr
impl Show for OrderByExpr

pub struct Parser {
  input : Array[Token]
  mut offset : Int
}

type ParserError
impl Show for ParserError

pub(all) enum Precedence {
  PlusMinus
  MulDivMod
  Eq
  Like
  And
  Or
  Between
}
fn Precedence::value(Self) -> Int

type PrimaryDatetimeField
impl Eq for PrimaryDatetimeField
impl Show for PrimaryDatetimeField

pub(all) enum Projection {
  Wildcard
  UnamedExpr(Expr)
  AliasedExpr(Expr, String)
}
impl Eq for Projection
impl Show for Projection

pub struct SelectStmt {
  projections : Array[Projection]
  from : Array[TableRef]
  where_clause : Expr?
  group_by : Array[Expr]
  having : Expr?
  order_by : Array[OrderByExpr]
  limit : Int?
  offset : Int?
}
impl Eq for SelectStmt
impl Show for SelectStmt

pub suberror SqlParserError {
  LexerError(LexerError)
  ParserError(ParserError)
}
impl Show for SqlParserError

pub(all) enum Statement {
  Select(SelectStmt)
}
impl Eq for Statement
impl Show for Statement

pub(all) enum TableRef {
  Table(String, String?)
  SubQuery(SelectStmt, String?)
}
impl Eq for TableRef
impl Show for TableRef

pub(all) enum Token {
  Keyword(Keyword)
  Identifier(String)
  Number(String)
  StringLiteral(String)
  Comma
  Semicolon
  Eq
  DoubleEq
  Neq
  Lt
  Gt
  LtEq
  GtEq
  Spaceship
  Plus
  Minus
  Mul
  Div
  Mod
  LBracket
  RBracket
  LBrace
  RBrace
  LParen
  RParen
  Period
  Unknown(Char)
  Eof
}
impl Eq for Token
impl Show for Token

pub(all) enum UnaryOperator {
  Negate
  Not
}
impl Eq for UnaryOperator
impl Show for UnaryOperator

// Type aliases

// Traits

